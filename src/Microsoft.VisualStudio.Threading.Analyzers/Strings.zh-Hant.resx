<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>改為 await {0}</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>改用 await</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>同步等候工作或 awaiter 可能會造成鎖死。請改用 await 或 JoinableTaskFactory.Run。</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>避免有問題的同步等候</value>
  </data>
  <data name="VSTHRD010_MessageFormat" xml:space="preserve">
    <value>主執行緒應明確使用類型 "{0}"。
請先呼叫 {1}() 或 await JoinableTaskFactory.SwitchToMainThreadAsync()。</value>
    <comment>{0} is a type name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>在主執行緒叫用單一執行緒類型</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>因為任何不是由 "async void" 方法處理的例外狀況都會使處理序損毀，所以請避免該方法。</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>避免 async void 方法</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>因為任何不是由 void 傳回委派類型處理的例外狀況都會使處理序損毀，所以請避免對該類型使用非同步 lambda。</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>避免不支援的非同步委派</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>AsyncEventHandler 委派應透過在 Microsoft.VisualStudio.Threading 組件中定義的延伸模組方法 "TplExtensions.InvokeAsync()" 叫用。</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>使用 InvokeAsync 引發非同步事件</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>當工作在委派外部初始化時，在 JoinableTaskFactory.Run 內的 Task 上呼叫 await，可能會造成潛在的鎖死情形。
您可以藉由確認工作在委派內初始化，或將 Task 改為使用 JoinableTask，來避免此問題。</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>避免在加入內容中等候不可加入的工作</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;.Value 可能會鎖死。
請改用 AsyncLazy&lt;T&gt;。</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>避免在 T 為 Task&lt;T2&gt; 時使用 Lazy&lt;T&gt;</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>{0} 會同步封鎖。請改為 await {1}。</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} 會同步封鎖。請改用 await。</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>在使用非同步方法時呼叫非同步方法</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>在必須同步時，請限制對公開輸入點成員使用 JoinableTaskFactory.Run 或 Task.Result 這類同步封鎖方法呼叫。對內部成員使用這種方法，可能會在非同步框架之間新增不必要的同步框架，而消耗執行緒集區。</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>以非同步方式實作內部邏輯</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>重新命名為 {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_MessageFormat" xml:space="preserve">
    <value>請在 Task 傳回方法的名稱中使用 "Async" 尾碼。</value>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>對非同步方法使用 "Async" 尾碼</value>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>請避免假設 TaskScheduler.Current 的方法多載。請使用接受 TaskScheduler 的多載，並明確指定 TaskScheduler.Default (或其他任一項)。</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>避免假設 TaskScheduler.Current 的方法多載</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>將傳回類型變更為 Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>在此呼叫 (或其他多載) 中提供 JoinableTaskFactory 執行個體，以避免主執行緒發生死結。</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>在允許的情況下提供 JoinableTaskFactory</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>公開此方法不會同步封鎖的非同步版本。接著將此方法簡化成在 JoinableTaskFactory.Run delegate 中呼叫該非同步方法。</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>提供非同步方法</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Await JoinableTaskFactory.SwitchToMainThreadAsync() 可切換至 UI 執行緒，而不會切換至可能會造成死結，或必須指定優先順序的 API。</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>避免傳統執行緒切換 API</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>"using" 運算式缺少 await 運算子。</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>using 運算式中的 Await Task</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>Await using 運算式</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_CodeFix_Await_Title" xml:space="preserve">
    <value>改用 await</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD108_MessageFormat" xml:space="preserve">
    <value>執行緒親和性檢查應該無條件。</value>
  </data>
  <data name="VSTHRD108_Title" xml:space="preserve">
    <value>無條件判斷提示執行緒親和性</value>
  </data>
  <data name="VSTHRD010_MessageFormat_NoAssertingMethod" xml:space="preserve">
    <value>主執行緒應明確使用類型 "{0}"。
先呼叫 Await JoinableTaskFactory.SwitchToMainThreadAsync()。</value>
    <comment>{0} is a type name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_MessageFormat_TransitiveMainThreadUser" xml:space="preserve">
    <value>因為此成員會叫用其他需要主執行緒的成員，所以請在成員主體開頭新增對 {0}() 的呼叫。</value>
    <comment>{0} is a method name.</comment>
  </data>
</root>