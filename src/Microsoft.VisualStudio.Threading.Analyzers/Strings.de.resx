<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Stattdessen auf {0} warten</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Stattdessen "await" verwenden</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>Das synchrone Warten auf Tasks oder Awaiters führt unter Umständen zu Deadlocks. Verwenden Sie stattdessen "await" oder JoinableTaskFactory.Run.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>Problematische synchrone Wartevorgänge vermeiden</value>
  </data>
  <data name="VSTHRD010_MessageFormat" xml:space="preserve">
    <value>Der Typ "{0}" muss explizit im Hauptthread verwendet werden.
Rufen Sie zuerst "{1}()" oder "await JoinableTaskFactory.SwitchToMainThreadAsync()" auf.</value>
    <comment>{0} is a type name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>Singlethread-Typen im Hauptthread aufrufen</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>Vermeiden Sie "async void"-Methoden, da Ausnahmen, die nicht von der Methode verarbeitet werden, zu einem Absturz des Prozesses führen.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>"async void"-Methoden vermeiden</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>Vermeiden Sie die Verwendung von Async Lambda für einen "void" zurückgebenden Delegattypen, da Ausnahmen, die nicht vom Delegaten verarbeitet werden, zu einem Absturz des Prozesses führen.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>Nicht unterstützte asynchrone Delegaten vermeiden</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>AsyncEventHandler-Delegaten müssen über die Erweiterungsmethode "TplExtensions.InvokeAsync()", die in der Microsoft.VisualStudio.Threading-Assembly definiert ist, aufgerufen werden.</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>InvokeAsync zum Auslösen asynchroner Ereignisse verwenden</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>Das Aufrufen von "await" für einen Task innerhalb von JoinableTaskFactory.Run führt unter Umständen zu Deadlocks, wenn der Task außerhalb des Delegaten initialisiert wird.
Sie können dies vermeiden, indem Sie sicherstellen, dass der Task innerhalb des Delegaten initialisiert wird, oder JoinableTask anstelle von Task verwenden.</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>Warten auf Tasks, für die kein Beitritt möglich ist, in Join-Kontexten vermeiden</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;.Value führt unter Umständen zu einem Deadlock.
Verwenden Sie stattdessen AsyncLazy&lt;T&gt;.</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>Die Verwendung von Lazy&lt;T&gt; vermeiden, wenn T ein Task&lt;T2&gt; ist</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>{0} synchron blockiert. Warten Sie stattdessen auf {1}.</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} synchron blockiert. Verwenden Sie stattdessen "await".</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>Asynchrone Methoden in einer asynchronen Methode aufrufen</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>Beschränken Sie die Verwendung synchron blockierender Methodenaufrufe wie JoinableTaskFactory.Run oder Task.Result auf öffentliche Einstiegspunktmitglieder, bei denen Sie synchron sein müssen. Wenn Sie sie für interne Mitglieder verwenden, werden asynchronen Frames unter Umständen unnötigerweise synchrone Frames hinzugefügt, was zu einer Auslastung des Threadpools führt.</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>Interne Logik asynchron implementieren</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>In {0} umbenennen</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_MessageFormat" xml:space="preserve">
    <value>Verwenden Sie das Suffix "Async" in Namen von Methoden, die Tasks zurückgeben.</value>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>Verwenden Sie das Suffix "Async" für asynchrone Methoden</value>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>Vermeiden Sie Methodenüberladungen, die TaskScheduler.Current annehmen. Verwenden Sie eine Überladung, die einen TaskScheduler akzeptiert, und geben Sie explizit TaskScheduler.Default (o. a.) an.</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>Methodenüberladungen, die TaskScheduler.Current annehmen, vermeiden</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>Rückgabetyp in Task ändern</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>Stellen Sie in diesem Aufruf (oder einer anderen Überladung) eine Instanz von "JoinableTaskFactory" bereit, um Deadlocks beim Hauptthread zu vermeiden.</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>"JoinableTaskFactory" bereitstellen, wenn zulässig</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>Machen Sie eine async-Version dieser Methode verfügbar, die nicht synchron blockiert. Vereinfachen Sie dann diese Methode so, dass sie diese asynchrone Methode innerhalb eines JoinableTaskFactory.Run-Delegats aufruft.</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>Asynchrone Methoden bieten</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Warten Sie darauf, dass "JoinableTaskFactory.SwitchToMainThreadAsync()" zum UI-Thread wechselt anstelle von APIs, bei denen Deadlocks auftreten können oder für die unter Umständen eine Priorität festgelegt werden muss.</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>Legacy-APIs zum Wechseln von Threads vermeiden</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>Der await-Operator für den "using"-Ausdruck fehlt.</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>Await Task im using-Ausdruck.</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>Await using-Ausdruck</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_CodeFix_Await_Title" xml:space="preserve">
    <value>Stattdessen "await" verwenden</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD108_MessageFormat" xml:space="preserve">
    <value>Überprüfungen der Threadaffinität dürfen keine Bedingungen umfassen.</value>
  </data>
  <data name="VSTHRD108_Title" xml:space="preserve">
    <value>Threadaffinität ohne Bedingungen bestätigen</value>
  </data>
  <data name="VSTHRD010_MessageFormat_NoAssertingMethod" xml:space="preserve">
    <value>Der Typ "{0}" muss explizit im Hauptthread verwendet werden.
Rufen Sie zuerst "await JoinableTaskFactory.SwitchToMainThreadAsync()" auf.</value>
    <comment>{0} is a type name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_MessageFormat_TransitiveMainThreadUser" xml:space="preserve">
    <value>Fügen Sie den Aufruf an "{0}()" am Beginn des Elementtexts hinzu, weil dieses Element andere Elemente aufruft, für die der Hauptthread erforderlich ist.</value>
    <comment>All placeholders are to type or member names.</comment>
  </data>
</root>