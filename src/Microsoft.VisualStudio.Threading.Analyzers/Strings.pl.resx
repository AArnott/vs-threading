<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Zamiast tego oczekuj na {0}</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Zamiast tego używaj oczekiwania</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSSDK001_MessageFormat" xml:space="preserve">
    <value>Synchroniczne oczekiwanie na zadania lub elementy typu awaiter mogą powodować zakleszczenia. Zamiast tego używaj metody JoinableTaskFactory.Run.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSSDK001_Title" xml:space="preserve">
    <value>Unikaj problematycznych oczekiwań synchronicznych</value>
  </data>
  <data name="VSSDK002_MessageFormat" xml:space="preserve">
    <value>Usługa programu Visual Studio „{0}” powinna być używana w wątku głównym w sposób jawny. 
Najpierw oczekuj na metodę JoinableTaskFactory.SwitchToMainThreadAsync() lub wywołaj metodę ThreadHelper.ThrowIfNotOnUIThread().</value>
  </data>
  <data name="VSSDK002_Title" xml:space="preserve">
    <value>Używaj usług programu VS z wątku interfejsu użytkownika</value>
  </data>
  <data name="VSSDK003_MessageFormat" xml:space="preserve">
    <value>Unikaj metod „async void”, ponieważ wszelkie wyjątki, które nie zostaną przez nie obsłużone, spowodują awarię procesu.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSSDK003_Title" xml:space="preserve">
    <value>Unikaj metod „async void”</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSSDK004_MessageFormat" xml:space="preserve">
    <value>Unikaj używania asynchronicznego wyrażenia lambda dla typu delegata zwracającego „void”, ponieważ wszelkie wyjątki, które nie zostaną obsłużone przez delegata, spowodują awarię procesu.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSSDK004_Title" xml:space="preserve">
    <value>Unikaj nieobsługiwanych delegatów asynchronicznych</value>
  </data>
  <data name="VSSDK005_MessageFormat" xml:space="preserve">
    <value>Delegatów AsyncEventHandler powinno się wywoływać za pośrednictwem metody rozszerzenia „TplExtensions.InvokeAsync()” zdefiniowanej w zestawie Microsoft.VisualStudio.Threading.</value>
  </data>
  <data name="VSSDK005_Title" xml:space="preserve">
    <value>Zdarzenia asynchroniczne wywołuj za pomocą metody InvokeAsync</value>
  </data>
  <data name="VSSDK006_MessageFormat" xml:space="preserve">
    <value>Wywołanie oczekiwania dla obiektu Task wewnątrz metody JoinableTaskFactory.Run, gdy dane zadanie zainicjowano poza delegatem, może spowodować zakleszczenia.
Tego problemu można uniknąć, zapewniając, że zadanie zostanie zainicjowane wewnątrz delegata lub za pomocą klasy JoinableTask (a nie klasy Task).</value>
  </data>
  <data name="VSSDK006_Title" xml:space="preserve">
    <value>Unikaj oczekiwania na zadania bez możliwości dołączenia w kontekstach dołączania</value>
  </data>
  <data name="VSSDK007_MessageFormat" xml:space="preserve">
    <value>Element Lazy&lt;Task&lt;T&gt;&gt;.Value może ulec zakleszczeniu.
Zamiast tego używaj klasy AsyncLazy&lt;T&gt;.</value>
  </data>
  <data name="VSSDK007_Title" xml:space="preserve">
    <value>Unikaj używania klasy Lazy&lt;T&gt;, jeśli T jest obiektem Task&lt;T2&gt;</value>
  </data>
  <data name="VSSDK008_MessageFormat" xml:space="preserve">
    <value>Metoda {0} powoduje blokowanie synchroniczne. Zamiast tego oczekuj na {1}.</value>
  </data>
  <data name="VSSDK008_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>Metoda {0} powoduje blokowanie synchroniczne. Zamiast tego używaj oczekiwania.</value>
  </data>
  <data name="VSSDK008_Title" xml:space="preserve">
    <value>W metodach asynchronicznych wywołuj metody asynchroniczne</value>
  </data>
  <data name="VSSDK009_MessageFormat" xml:space="preserve">
    <value>Ogranicz stosowanie wywołań metod z blokowaniem synchronicznym, takich jak JoinableTaskFactory.Run lub Task.Result, do publicznych elementów członkowskich punktów wyjścia, w przypadku których konieczne jest działanie synchroniczne. Stosowanie tego rozwiązania w przypadku wewnętrznych elementów członkowskich może powodować niepotrzebne dodawanie ramek synchronicznych między ramkami asynchronicznymi, co może prowadzić do wyczerpania puli wątków.</value>
  </data>
  <data name="VSSDK009_Title" xml:space="preserve">
    <value>Logikę wewnętrzną implementuj asynchronicznie</value>
  </data>
  <data name="VSSDK010_CodeFix_Title" xml:space="preserve">
    <value>Zmień nazwę na: {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSSDK010_MessageFormat" xml:space="preserve">
    <value>W nazwach metod zwracających obiekty Task używaj sufiksu „Async”.</value>
  </data>
  <data name="VSSDK010_Title" xml:space="preserve">
    <value>W przypadku metod asynchronicznych używaj sufiksu „Async”</value>
  </data>
  <data name="VSSDK011_MessageFormat" xml:space="preserve">
    <value>Unikaj przeciążeń metod zakładających korzystanie z właściwości TaskScheduler.Current. Używaj przeciążenia przyjmującego obiekt TaskScheduler i jawnie określaj właściwość TaskScheduler.Default (lub inną).</value>
  </data>
  <data name="VSSDK011_Title" xml:space="preserve">
    <value>Unikaj przeciążeń metod zakładających korzystanie z właściwości TaskScheduler.Current</value>
  </data>
  <data name="VSSDK003_CodeFix_Title" xml:space="preserve">
    <value>Zmień zwracany typ na Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
</root>