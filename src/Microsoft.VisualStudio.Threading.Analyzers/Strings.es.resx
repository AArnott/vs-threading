<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Use await {0} en su lugar</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Use await en su lugar</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>La espera sincrónica de tareas o elementos que ejecutan await puede provocar interbloqueos. Use JoinableTaskFactory.Run en su lugar.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>Evite esperas sincrónicas problemáticas</value>
  </data>
  <data name="VSTHRD010_MessageFormat" xml:space="preserve">
    <value>El servicio "{0}" de Visual Studio debe usarse explícitamente en el subproceso principal. 
Llame a ThreadHelper.ThrowIfNotOnUIThread() o el elemento await JoinableTaskFactory.SwitchToMainThreadAsync() en primer lugar.</value>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>Use servicios de VS desde el subproceso de IU</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>Evite métodos "async void", porque las excepciones no controladas por el método bloquearán el proceso.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>Evite métodos async void</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>Evite usar la lambda async para un tipo de delegado de devolución void, porque las excepciones no controladas por el delegado bloquearán el proceso.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>Evite delegados asincrónicos no compatibles</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>Los delegados de AsyncEventHandler deben invocarse a través del método de extensión "TplExtensions.InvokeAsync()" definido en el ensamblado Microsoft.VisualStudio.Threading.</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>Use InvokeAsync para desencadenar eventos asincrónicos</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>La llamada a await en un elemento Task dentro de JoinableTaskFactory.Run, cuando la tarea se ha iniciado fuera del delegado, puede provocar potenciales interbloqueos.
Puede evitar este problema asegurándose de que la tarea se ha iniciado dentro del delegado o usando JoinableTask en lugar de Task.</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>Evite usar await para tareas que no sean de unión en contextos de unión</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;.Value puede provocar interbloqueos.
Use AsyncLazy&lt;T&gt; en su lugar.</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>Evite el uso de Lazy&lt;T&gt; donde T es Task&lt;T2&gt;</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>{0} bloquea sincrónicamente. Use await {1} en su lugar.</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} bloquea sincrónicamente. Use await en su lugar.</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>Llame a métodos asincrónicos cuando esté en un método asincrónico</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>Limite el uso de llamadas de métodos de bloqueo sincrónico, como JoinableTaskFactory.Run o Task.Result, a miembros de punto de entrada públicos donde tiene que ser sincrónico. El uso para miembros internos puede agregar innecesariamente marcos sincrónicos entre marcos asincrónicos, provocando el agotamiento del conjunto de subprocesos.</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>Implemente la lógica interna asincrónicamente</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>Cambie el nombre a {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_MessageFormat" xml:space="preserve">
    <value>Use el sufijo "Async" en nombres de métodos de devolución de elementos Task</value>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>Use el sufijo "Async" para métodos asincrónicos</value>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>Evite las sobrecargas de métodos que asumen TaskScheduler.Current. Use una sobrecarga que acepte un elemento TaskScheduler y especifique TaskScheduler.Default (o cualquier otro) explícitamente.</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>Evite las sobrecargas de métodos que asumen TaskScheduler.Current</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>Cambie el tipo de valor devuelto a Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
</root>