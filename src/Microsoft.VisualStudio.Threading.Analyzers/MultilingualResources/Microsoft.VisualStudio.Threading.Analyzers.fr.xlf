<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="fr" original="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" tool-id="MultilingualAppToolkit" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="MultilingualAppToolkit" tool-name="Multilingual App Toolkit" tool-version="4.0.1795.0" tool-company="Microsoft" />
    </header>
    <body>
      <group id="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" datatype="resx">
        <trans-unit id="AwaitXInstead" translate="yes" xml:space="preserve">
          <source>Await {0} instead</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Attendre de {0} plutôt</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.
{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>Use await instead</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Utilisation vous attendent à la place</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK001_MessageFormat" translate="yes" xml:space="preserve">
          <source>Synchronous wait on tasks or awaiters is dangerous and may cause dead locks. Please consider the following options: 1) Switch to asynchronous wait if the caller is already a "async" method. 2) Change the chain of callers to be "async" methods, and then change this code to be asynchronous await. 3) Use JoinableTaskFactory.Run() to wait on the tasks or awaiters. Refer to http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Attente synchrone sur les tâches ou les entités awaiter est dangereux et peut causer des serrures. S’il vous plaît envisager les options suivantes : 1) passer à attente asynchrone si l’appelant est déjà une méthode « async ». 2) changement de la chaîne des appelants d’être « async » méthodes et modifiez ce code pour être asynchrone vous attendent. 3) utilisez JoinableTaskFactory.Run() pour attendre les tâches ou les entités awaiter. Consultez http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx pour plus d’informations.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK001_Title" translate="yes" xml:space="preserve">
          <source>Avoid problematic synchronous waits</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Attente synchrone sur les tâches ou les entités awaiter est dangereux et peut causer des serrures.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK002_MessageFormat" translate="yes" xml:space="preserve">
          <source>Visual Studio service "{0}" should be used on main thread explicitly. 
Please either verify the current thread is main thread, or switch to main thread asynchronously. 
1) APIs to verify the current thread is main thread: ThreadHelper.ThrowIfNotOnUIThread(), or IThreadHandling.VerifyOnUIThread(). 
2) APIs to switch to main thread asynchronously: JoinableTaskFactory.SwitchToMainThreadAsync(), or IThreadHandling.SwitchToUIThread(). 
Refer to http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Service de Visual Studio « {0} » doit être utilisé explicitement sur le thread principal. 
S’il vous plaît soit vérifier le thread actuel est le thread principal ou basculer vers le thread principal de façon asynchrone. 
1) API pour vérifier le thread en cours sont le thread principal : ThreadHelper.ThrowIfNotOnUIThread(), ou IThreadHandling.VerifyOnUIThread(). 
2) API pour passer au principal thread asynchrone : JoinableTaskFactory.SwitchToMainThreadAsync() ou IThreadHandling.SwitchToUIThread(). 
Se reporter à http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx pour plus d’informations.</target>
        </trans-unit>
        <trans-unit id="VSSDK002_Title" translate="yes" xml:space="preserve">
          <source>Visual Studio service should be used on main thread explicitly</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Service de Visual Studio devrait être utilisé explicitement sur le thread principal.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK003_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid Async Void method, because any exceptions thrown out of an async void method will be raised directly on the SynchronizationContext and will crash the process. 
Refer to https://msdn.microsoft.com/en-us/magazine/jj991977.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Éviter la méthode Async vide, parce que toutes les exceptions levées par une méthode de vide async se poseront directement sur le SynchronizationContext et vont planter le processus. 
Se reporter à https://msdn.microsoft.com/en-us/magazine/jj991977.aspx pour plus d’informations.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSSDK003_Title" translate="yes" xml:space="preserve">
          <source>Avoid async void methods</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Éviter la méthode Async vide.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSSDK004_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid using async lambda as void returning delegate type, because any exceptions thrown out of an async lambda returning void will be raised directly on the SynchronizationContext and will crash the process. 
Refer to https://msdn.microsoft.com/en-us/magazine/jj991977.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Évitez d’utiliser async lambda comme type de délégué de retour void, car toutes les exceptions levées par une lambda async retourner void se poseront directement sur le SynchronizationContext et vont planter le processus. 
Se reporter à https://msdn.microsoft.com/en-us/magazine/jj991977.aspx pour plus d’informations.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK004_Title" translate="yes" xml:space="preserve">
          <source>Avoid unsupported async delegates</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Async lambda est utilisé comme type de délégué de retour void.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK005_MessageFormat" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Les délégués de AsyncEventHandler doivent être appelés par l’intermédiaire de la méthode d’extension « TplExtensions.InvokeAsync() » défini dans Microsoft.VisualStudio.Threading assembly.</target>
        </trans-unit>
        <trans-unit id="VSSDK005_Title" translate="yes" xml:space="preserve">
          <source>Use InvokeAsync to raise async events</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Les délégués de AsyncEventHandler doivent être appelés par l’intermédiaire de la méthode d’extension « TplExtensions.InvokeAsync() » défini dans Microsoft.VisualStudio.Threading assembly.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK006_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling await on a Task inside a JoinableTaskFactory.Run, when the task is initialized outside the delegate can cause potential deadlocks.
You can avoid this problem by ensuring the task is initialized within the delegate or by using JoinableTask instead of Task.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Appel vous attendent sur une tâche à l’intérieur d’un JoinableTaskFactory.Run, lorsque la tâche est initialisée à l’extérieur le délégué peut provoquer des blocages éventuels. 
Vous pouvez éviter ce problème en s’assurant que la tâche est initialisée au sein du délégué ou à l’aide de JoinableTask au lieu de travail.</target>
        </trans-unit>
        <trans-unit id="VSSDK006_Title" translate="yes" xml:space="preserve">
          <source>Avoid awaiting non-joinable tasks in join contexts</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Éviter d’appeler attendent la tâche à l’intérieur de la « JoinableTaskFactory.Run » délégué lorsque la tâche est définie en dehors du délégué pour éviter les blocages éventuels.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK007_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock when the value factory was previously started.
You should use AsyncLazy&lt;T&gt; instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">L’appel de paresseux&lt;Task&lt;T&gt;&gt;. Valeur peut se bloquer lorsque l’usine de valeur a été précédemment démarrée. 
Vous devez plutôt utiliser AsyncLazy&lt;T&gt; .</target>
        </trans-unit>
        <trans-unit id="VSSDK007_Title" translate="yes" xml:space="preserve">
          <source>Avoid using Lazy<it id="1" pos="open">&lt;T&gt;</it> where T is a Task.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Évitez d’utiliser Lazy<it id="1" pos="open"> &lt;T&gt; </it> où T est une tâche.</target>
        </trans-unit>
        <trans-unit id="VSSDK008_MessageFormat" translate="yes" xml:space="preserve">
          <source>The {0} member synchronously blocks. Call {1} instead and await its result.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Le membre {0} bloque de façon synchrone. Appelez plutôt les {1} et attendre son résultat.</target>
        </trans-unit>
        <trans-unit id="VSSDK008_MessageFormat_UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>The {0} member synchronously blocks. Use await instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Le membre {0} bloque de façon synchrone. Utilisation vous attendent à la place.</target>
        </trans-unit>
        <trans-unit id="VSSDK008_Title" translate="yes" xml:space="preserve">
          <source>Call awaitable alternatives when in an async method.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Appelez await alternatives lorsque dans une méthode async.</target>
        </trans-unit>
        <trans-unit id="VSSDK009_MessageFormat" translate="yes" xml:space="preserve">
          <source>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Limite l’utilisation de blocage synchrone des appels de méthodes telles que JoinableTaskFactory.Run ou Task.Result aux membres entrypoint public où vous devez être synchrone. L’utiliser pour des membres internes peut ajouter inutilement synchrones images entre les images asynchrones, conduisant à l’épuisement du pool de threads.</target>
        </trans-unit>
        <trans-unit id="VSSDK009_Title" translate="yes" xml:space="preserve">
          <source>Avoid synchronous blocks in non-public methods.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Éviter les blocs synchrones dans les méthodes non publiques.</target>
        </trans-unit>
        <trans-unit id="VSSDK010_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Rename to {0}</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Remplacez {0}.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="VSSDK010_MessageFormat" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix in names of Task-returning methods.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Utilisez « Async » suffixe de tâche retourne les noms de méthodes.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK010_Title" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix for async methods.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">Utilisez « Async » suffixe de tâche retourne les noms de méthodes.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>