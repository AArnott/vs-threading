<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="zh-Hans" original="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" tool-id="MultilingualAppToolkit" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="MultilingualAppToolkit" tool-name="Multilingual App Toolkit" tool-version="4.0.1795.0" tool-company="Microsoft" />
    </header>
    <body>
      <group id="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" datatype="resx">
        <trans-unit id="AwaitXInstead" translate="yes" xml:space="preserve">
          <source>Await {0} instead</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">而等待 {0}</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.
{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>Use await instead</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">使用等待相反</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK001_MessageFormat" translate="yes" xml:space="preserve">
          <source>Synchronous wait on tasks or awaiters is dangerous and may cause dead locks. Please consider the following options: 1) Switch to asynchronous wait if the caller is already a "async" method. 2) Change the chain of callers to be "async" methods, and then change this code to be asynchronous await. 3) Use JoinableTaskFactory.Run() to wait on the tasks or awaiters. Refer to http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">在任务或等待程序同步等待是危险的可能会导致死锁。请考虑以下选项︰ 1) 切换到异步等待呼叫者是否已经"async"方法。2） 链的调用方，并将"async"方法，然后更改此代码是异步等待的变化。3） 使用 JoinableTaskFactory.Run() 来伺候的任务或等待程序。请参阅 http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx 更多的信息。</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK001_Title" translate="yes" xml:space="preserve">
          <source>Synchronous wait on tasks or awaiters is dangerous and may cause dead locks.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">在任务或等待程序同步等待是危险的可能会导致死锁。</target>
        </trans-unit>
        <trans-unit id="VSSDK002_MessageFormat" translate="yes" xml:space="preserve">
          <source>Visual Studio service "{0}" should be used on main thread explicitly. 
Please either verify the current thread is main thread, or switch to main thread asynchronously. 
1) APIs to verify the current thread is main thread: ThreadHelper.ThrowIfNotOnUIThread(), or IThreadHandling.VerifyOnUIThread(). 
2) APIs to switch to main thread asynchronously: JoinableTaskFactory.SwitchToMainThreadAsync(), or IThreadHandling.SwitchToUIThread(). 
Refer to http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">视觉工作室服务"{0}"应明确在主线程上使用。
请或者验证当前线程是主线程，或者切换到主线程以异步方式。
1) Api 来验证当前线程是主线程︰ ThreadHelper.ThrowIfNotOnUIThread() 或 IThreadHandling.VerifyOnUIThread()。
2) Api 来切换到主线程以异步方式︰ JoinableTaskFactory.SwitchToMainThreadAsync() 或 IThreadHandling.SwitchToUIThread()。对 http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx 的更多信息请参阅
。</target>
        </trans-unit>
        <trans-unit id="VSSDK002_Title" translate="yes" xml:space="preserve">
          <source>Visual Studio service should be used on main thread explicitly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">视觉工作室服务应明确在主线程上使用。</target>
        </trans-unit>
        <trans-unit id="VSSDK003_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid Async Void method, because any exceptions thrown out of an async void method will be raised directly on the SynchronizationContext and will crash the process. 
Refer to https://msdn.microsoft.com/en-us/magazine/jj991977.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免异步 Void 方法，因为从异步 void 方法引发的任何异常将直接在 SynchronizationContext 上提出，将会使进程崩溃。对 https://msdn.microsoft.com/en-us/magazine/jj991977.aspx 的更多信息请参阅
。</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSSDK003_Title" translate="yes" xml:space="preserve">
          <source>Avoid Async Void method.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免异步 Void 方法。</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSSDK004_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid using async lambda as void returning delegate type, because any exceptions thrown out of an async lambda returning void will be raised directly on the SynchronizationContext and will crash the process. 
Refer to https://msdn.microsoft.com/en-us/magazine/jj991977.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免使用异步 lambda 作为 void 返回委托类型，因为从返回 void 异步 lambda 引发的任何异常将直接在 SynchronizationContext 上提出，将会使进程崩溃。对 https://msdn.microsoft.com/en-us/magazine/jj991977.aspx 的更多信息请参阅
。</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK004_Title" translate="yes" xml:space="preserve">
          <source>Async lambda is being used as void returning delegate type.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">异步 lambda 是被用作 void 返回委托类型。</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK005_MessageFormat" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">AsyncEventHandler 代表应该通过"TplExtensions.InvokeAsync()"Microsoft.VisualStudio.Threading 程序集中定义的扩展方法调用。</target>
        </trans-unit>
        <trans-unit id="VSSDK005_Title" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">AsyncEventHandler 代表应该通过"TplExtensions.InvokeAsync()"Microsoft.VisualStudio.Threading 程序集中定义的扩展方法调用。</target>
        </trans-unit>
        <trans-unit id="VSSDK006_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling await on a Task inside a JoinableTaskFactory.Run, when the task is initialized outside the delegate can cause potential deadlocks.
You can avoid this problem by ensuring the task is initialized within the delegate or by using JoinableTask instead of Task.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">呼叫等待任务里面的 JoinableTaskFactory.Run，这项任务委托外面的初始化时可能导致潜在的死锁。
通过确保任务初始化委托内或通过使用 JoinableTask 而不任务，你可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="VSSDK006_Title" translate="yes" xml:space="preserve">
          <source>Avoid calling await Task inside "JoinableTaskFactory.Run" delegate when Task is defined outside the delegate to avoid potential deadlocks.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免调用内"JoinableTaskFactory.Run"委托等待任务，当任务定义之外的委托，以避免潜在的死锁。</target>
        </trans-unit>
        <trans-unit id="VSSDK007_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock when the value factory was previously started.
You should use AsyncLazy&lt;T&gt; instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">调用懒&lt;Task&lt;T&gt;&gt;。值工厂以前启动时，值会出现死锁。您应改用 AsyncLazy&lt;T&gt; 
。</target>
        </trans-unit>
        <trans-unit id="VSSDK007_Title" translate="yes" xml:space="preserve">
          <source>Avoid using Lazy<it id="1" pos="open">&lt;T&gt;</it> where T is a Task.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免使用懒<it id="1" pos="open">&lt;T&gt;</it>其中 T 一项任务。</target>
        </trans-unit>
        <trans-unit id="VSSDK008_MessageFormat" translate="yes" xml:space="preserve">
          <source>The {0} member synchronously blocks. Call {1} instead and await its result.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">{0} 成员同步块。改用 {1} 并等待其结果。</target>
        </trans-unit>
        <trans-unit id="VSSDK008_MessageFormat_UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>The {0} member synchronously blocks. Use await instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">{0} 成员同步块。使用等待相反。</target>
        </trans-unit>
        <trans-unit id="VSSDK008_Title" translate="yes" xml:space="preserve">
          <source>Call awaitable alternatives when in an async method.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">可等待的替代品时异步方法调用</target>
        </trans-unit>
        <trans-unit id="VSSDK009_MessageFormat" translate="yes" xml:space="preserve">
          <source>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">限制使用的同步阻塞如 JoinableTaskFactory.Run 或 Task.Result 各位公共入口点，在那里你必须同步的方法调用。它为内部成员可以使用不必要添加同步帧之间异步帧，导致线程池用尽。</target>
        </trans-unit>
        <trans-unit id="VSSDK009_Title" translate="yes" xml:space="preserve">
          <source>Avoid synchronous blocks in non-public methods.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免使用同步块中的非公共方法。</target>
        </trans-unit>
        <trans-unit id="VSSDK010_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Rename to {0}</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">重命名为 {0}。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
          <note from="MultilingualBuild" annotates="source" priority="2">{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="VSSDK010_MessageFormat" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix in names of Task-returning methods.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">在任务返回方法名称中使用"Async"后缀。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK010_Title" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix for async methods.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">在任务返回方法名称中使用"Async"后缀。</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK011_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid method overloads that assume TaskScheduler.Current. Use an overload that accepts a TaskScheduler and specify TaskScheduler.Default (or any other) explicitly.</source>
          <target state="new">Avoid method overloads that assume TaskScheduler.Current. Use an overload that accepts a TaskScheduler and specify TaskScheduler.Default (or any other) explicitly.</target>
        </trans-unit>
        <trans-unit id="VSSDK011_Title" translate="yes" xml:space="preserve">
          <source>Avoid method overloads that assume TaskScheduler.Current</source>
          <target state="new">Avoid method overloads that assume TaskScheduler.Current</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>