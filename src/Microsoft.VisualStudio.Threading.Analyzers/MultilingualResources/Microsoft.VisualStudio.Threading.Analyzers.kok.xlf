<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="kok" original="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" tool-id="MultilingualAppToolkit" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="MultilingualAppToolkit" tool-name="Multilingual App Toolkit" tool-version="4.0.1795.0" tool-company="Microsoft" />
    </header>
    <body>
      <group id="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" datatype="resx">
        <trans-unit id="AwaitXInstead" translate="yes" xml:space="preserve">
          <source>Await {0} instead</source>
          <target state="new">Await {0} instead</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.
{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>Use await instead</source>
          <target state="new">Use await instead</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK001_MessageFormat" translate="yes" xml:space="preserve">
          <source>Synchronous wait on tasks or awaiters is dangerous and may cause dead locks. Please consider the following options: 1) Switch to asynchronous wait if the caller is already a "async" method. 2) Change the chain of callers to be "async" methods, and then change this code to be asynchronous await. 3) Use JoinableTaskFactory.Run() to wait on the tasks or awaiters. Refer to http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx for more info.</source>
          <target state="new">Synchronous wait on tasks or awaiters is dangerous and may cause dead locks. Please consider the following options: 1) Switch to asynchronous wait if the caller is already a "async" method. 2) Change the chain of callers to be "async" methods, and then change this code to be asynchronous await. 3) Use JoinableTaskFactory.Run() to wait on the tasks or awaiters. Refer to http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx for more info.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK001_Title" translate="yes" xml:space="preserve">
          <source>Synchronous wait on tasks or awaiters is dangerous and may cause dead locks.</source>
          <target state="new">Synchronous wait on tasks or awaiters is dangerous and may cause dead locks.</target>
        </trans-unit>
        <trans-unit id="VSSDK002_MessageFormat" translate="yes" xml:space="preserve">
          <source>Visual Studio service "{0}" should be used on main thread explicitly. 
Please either verify the current thread is main thread, or switch to main thread asynchronously. 
1) APIs to verify the current thread is main thread: ThreadHelper.ThrowIfNotOnUIThread(), or IThreadHandling.VerifyOnUIThread(). 
2) APIs to switch to main thread asynchronously: JoinableTaskFactory.SwitchToMainThreadAsync(), or IThreadHandling.SwitchToUIThread(). 
Refer to http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx for more info.</source>
          <target state="new">Visual Studio service "{0}" should be used on main thread explicitly. 
Please either verify the current thread is main thread, or switch to main thread asynchronously. 
1) APIs to verify the current thread is main thread: ThreadHelper.ThrowIfNotOnUIThread(), or IThreadHandling.VerifyOnUIThread(). 
2) APIs to switch to main thread asynchronously: JoinableTaskFactory.SwitchToMainThreadAsync(), or IThreadHandling.SwitchToUIThread(). 
Refer to http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx for more info.</target>
        </trans-unit>
        <trans-unit id="VSSDK002_Title" translate="yes" xml:space="preserve">
          <source>Visual Studio service should be used on main thread explicitly.</source>
          <target state="new">Visual Studio service should be used on main thread explicitly.</target>
        </trans-unit>
        <trans-unit id="VSSDK003_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid Async Void method, because any exceptions thrown out of an async void method will be raised directly on the SynchronizationContext and will crash the process. 
Refer to https://msdn.microsoft.com/en-us/magazine/jj991977.aspx for more info.</source>
          <target state="new">Avoid Async Void method, because any exceptions thrown out of an async void method will be raised directly on the SynchronizationContext and will crash the process. 
Refer to https://msdn.microsoft.com/en-us/magazine/jj991977.aspx for more info.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSSDK003_Title" translate="yes" xml:space="preserve">
          <source>Avoid Async Void method.</source>
          <target state="new">Avoid Async Void method.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSSDK004_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid using async lambda as void returning delegate type, because any exceptions thrown out of an async lambda returning void will be raised directly on the SynchronizationContext and will crash the process. 
Refer to https://msdn.microsoft.com/en-us/magazine/jj991977.aspx for more info.</source>
          <target state="new">Avoid using async lambda as void returning delegate type, because any exceptions thrown out of an async lambda returning void will be raised directly on the SynchronizationContext and will crash the process. 
Refer to https://msdn.microsoft.com/en-us/magazine/jj991977.aspx for more info.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK004_Title" translate="yes" xml:space="preserve">
          <source>Async lambda is being used as void returning delegate type.</source>
          <target state="new">Async lambda is being used as void returning delegate type.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK005_MessageFormat" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="new">AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</target>
        </trans-unit>
        <trans-unit id="VSSDK005_Title" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="new">AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</target>
        </trans-unit>
        <trans-unit id="VSSDK006_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling await on a Task inside a JoinableTaskFactory.Run, when the task is initialized outside the delegate can cause potential deadlocks.
You can avoid this problem by ensuring the task is initialized within the delegate or by using JoinableTask instead of Task.</source>
          <target state="new">Calling await on a Task inside a JoinableTaskFactory.Run, when the task is initialized outside the delegate can cause potential deadlocks.
You can avoid this problem by ensuring the task is initialized within the delegate or by using JoinableTask instead of Task.</target>
        </trans-unit>
        <trans-unit id="VSSDK006_Title" translate="yes" xml:space="preserve">
          <source>Avoid calling await Task inside "JoinableTaskFactory.Run" delegate when Task is defined outside the delegate to avoid potential deadlocks.</source>
          <target state="new">Avoid calling await Task inside "JoinableTaskFactory.Run" delegate when Task is defined outside the delegate to avoid potential deadlocks.</target>
        </trans-unit>
        <trans-unit id="VSSDK007_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock when the value factory was previously started.
You should use AsyncLazy&lt;T&gt; instead.</source>
          <target state="new">Calling Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock when the value factory was previously started.
You should use AsyncLazy&lt;T&gt; instead.</target>
        </trans-unit>
        <trans-unit id="VSSDK007_Title" translate="yes" xml:space="preserve">
          <source>Avoid using Lazy<it id="1" pos="open">&lt;T&gt;</it> where T is a Task.</source>
          <target state="new">Avoid using Lazy<it id="1" pos="open">&lt;T&gt;</it> where T is a Task.</target>
        </trans-unit>
        <trans-unit id="VSSDK008_MessageFormat" translate="yes" xml:space="preserve">
          <source>The {0} member synchronously blocks. Call {1} instead and await its result.</source>
          <target state="new">The {0} member synchronously blocks. Call {1} instead and await its result.</target>
        </trans-unit>
        <trans-unit id="VSSDK008_MessageFormat_UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>The {0} member synchronously blocks. Use await instead.</source>
          <target state="new">The {0} member synchronously blocks. Use await instead.</target>
        </trans-unit>
        <trans-unit id="VSSDK008_Title" translate="yes" xml:space="preserve">
          <source>Call awaitable alternatives when in an async method.</source>
          <target state="new">Call awaitable alternatives when in an async method.</target>
        </trans-unit>
        <trans-unit id="VSSDK009_MessageFormat" translate="yes" xml:space="preserve">
          <source>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</source>
          <target state="new">Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</target>
        </trans-unit>
        <trans-unit id="VSSDK009_Title" translate="yes" xml:space="preserve">
          <source>Avoid synchronous blocks in non-public methods.</source>
          <target state="new">Avoid synchronous blocks in non-public methods.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>