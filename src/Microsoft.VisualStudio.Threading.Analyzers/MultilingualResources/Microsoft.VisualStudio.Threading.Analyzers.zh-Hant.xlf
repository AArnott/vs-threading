<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="zh-Hant" original="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" tool-id="MultilingualAppToolkit" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="MultilingualAppToolkit" tool-name="Multilingual App Toolkit" tool-version="4.0.1795.0" tool-company="Microsoft" />
    </header>
    <body>
      <group id="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" datatype="resx">
        <trans-unit id="AwaitXInstead" translate="yes" xml:space="preserve">
          <source>Await {0} instead</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">而等待 {0}</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.
{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>Use await instead</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">使用等待相反</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK001_MessageFormat" translate="yes" xml:space="preserve">
          <source>Synchronous wait on tasks or awaiters is dangerous and may cause dead locks. Please consider the following options: 1) Switch to asynchronous wait if the caller is already a "async" method. 2) Change the chain of callers to be "async" methods, and then change this code to be asynchronous await. 3) Use JoinableTaskFactory.Run() to wait on the tasks or awaiters. Refer to http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">在任務或等待程式同步等待是危險的可能會導致鎖死。請考慮以下選項︰ 1) 切換到非同步等待來電者是否已經"async"方法。2） 鏈的調用方，並將"async"方法，然後更改此代碼是非同步等待的變化。3） 使用 JoinableTaskFactory.Run() 來伺候的任務或等待程式。請參閱 HTTP://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx 更多的資訊。</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK001_Title" translate="yes" xml:space="preserve">
          <source>Synchronous wait on tasks or awaiters is dangerous and may cause dead locks.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">在任務或等待程式同步等待是危險的可能會導致鎖死。</target>
        </trans-unit>
        <trans-unit id="VSSDK002_MessageFormat" translate="yes" xml:space="preserve">
          <source>Visual Studio service "{0}" should be used on main thread explicitly. 
Please either verify the current thread is main thread, or switch to main thread asynchronously. 
1) APIs to verify the current thread is main thread: ThreadHelper.ThrowIfNotOnUIThread(), or IThreadHandling.VerifyOnUIThread(). 
2) APIs to switch to main thread asynchronously: JoinableTaskFactory.SwitchToMainThreadAsync(), or IThreadHandling.SwitchToUIThread(). 
Refer to http://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">視覺工作室服務"{0}"應明確在主執行緒上使用。
請或者驗證當前執行緒是主執行緒，或者切換到主執行緒以非同步方式。
1) Api 來驗證當前執行緒是主執行緒︰ ThreadHelper.ThrowIfNotOnUIThread() 或 IThreadHandling.VerifyOnUIThread()。
2) Api 來切換到主執行緒以非同步方式︰ JoinableTaskFactory.SwitchToMainThreadAsync() 或 IThreadHandling.SwitchToUIThread()。對 HTTP://blogs.msdn.com/b/andrewarnottms/archive/2014/05/07/asynchronous-and-multithreaded-programming-within-vs-using-the-joinabletaskfactory.aspx 的更多資訊請參閱
。</target>
        </trans-unit>
        <trans-unit id="VSSDK002_Title" translate="yes" xml:space="preserve">
          <source>Visual Studio service should be used on main thread explicitly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">視覺工作室服務應明確在主執行緒上使用。</target>
        </trans-unit>
        <trans-unit id="VSSDK003_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid Async Void method, because any exceptions thrown out of an async void method will be raised directly on the SynchronizationContext and will crash the process. 
Refer to https://msdn.microsoft.com/en-us/magazine/jj991977.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免非同步 Void 方法，因為從非同步 void 方法引發的任何異常將直接在 SynchronizationCoNtext 上提出，將會使進程崩潰。對 HTTPs://msdn.microsoft.com/en-us/magazine/jj991977.aspx 的更多資訊請參閱
。</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSSDK003_Title" translate="yes" xml:space="preserve">
          <source>Avoid Async Void method.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免非同步 Void 方法。</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSSDK004_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid using async lambda as void returning delegate type, because any exceptions thrown out of an async lambda returning void will be raised directly on the SynchronizationContext and will crash the process. 
Refer to https://msdn.microsoft.com/en-us/magazine/jj991977.aspx for more info.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免使用非同步 lambda 作為 void 返回委託類型，因為從返回 void 非同步 lambda 引發的任何異常將直接在 SynchronizationCoNtext 上提出，將會使進程崩潰。對 HTTPs://msdn.microsoft.com/en-us/magazine/jj991977.aspx 的更多資訊請參閱
。</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK004_Title" translate="yes" xml:space="preserve">
          <source>Async lambda is being used as void returning delegate type.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">非同步 lambda 是被用作 void 返回委託類型。</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSSDK005_MessageFormat" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">AsyncEventHandler 代表應該通過"TplExtensions.InvokeAsync()"Microsoft.VisualStudio.Threading 程式集中定義的擴充方法調用。</target>
        </trans-unit>
        <trans-unit id="VSSDK005_Title" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">AsyncEventHandler 代表應該通過"TplExtensions.InvokeAsync()"Microsoft.VisualStudio.Threading 程式集中定義的擴充方法調用。</target>
        </trans-unit>
        <trans-unit id="VSSDK006_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling await on a Task inside a JoinableTaskFactory.Run, when the task is initialized outside the delegate can cause potential deadlocks.
You can avoid this problem by ensuring the task is initialized within the delegate or by using JoinableTask instead of Task.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">呼叫等待任務裡面的 JoinableTaskFactory.Run，這項任務委託外面的初始化時可能導致潛在的鎖死。
通過確保任務初始化委託內或通過使用 JoinableTask 而不任務，你可以避免此問題。</target>
        </trans-unit>
        <trans-unit id="VSSDK006_Title" translate="yes" xml:space="preserve">
          <source>Avoid calling await Task inside "JoinableTaskFactory.Run" delegate when Task is defined outside the delegate to avoid potential deadlocks.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免調用內"JoinableTaskFactory.Run"委託等待任務，當任務定義之外的委託，以避免潛在的鎖死。</target>
        </trans-unit>
        <trans-unit id="VSSDK007_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock when the value factory was previously started.
You should use AsyncLazy&lt;T&gt; instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">調用懶&lt;Task&lt;T&gt;&gt;。值工廠以前啟動時，值會出現鎖死。您應改用 AsyncLazy&lt;T&gt; 
。</target>
        </trans-unit>
        <trans-unit id="VSSDK007_Title" translate="yes" xml:space="preserve">
          <source>Avoid using Lazy<it id="1" pos="open">&lt;T&gt;</it> where T is a Task.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免使用懶<it id="1" pos="open">&lt;T&gt;</it>其中 T 一項任務。</target>
        </trans-unit>
        <trans-unit id="VSSDK008_MessageFormat" translate="yes" xml:space="preserve">
          <source>The {0} member synchronously blocks. Call {1} instead and await its result.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">{0} 成員同步塊。改用 {1} 並等待其結果。</target>
        </trans-unit>
        <trans-unit id="VSSDK008_MessageFormat_UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>The {0} member synchronously blocks. Use await instead.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">{0} 成員同步塊。使用等待相反。</target>
        </trans-unit>
        <trans-unit id="VSSDK008_Title" translate="yes" xml:space="preserve">
          <source>Call awaitable alternatives when in an async method.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">可等待的替代品時非同步方法調用</target>
        </trans-unit>
        <trans-unit id="VSSDK009_MessageFormat" translate="yes" xml:space="preserve">
          <source>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">限制使用的同步阻塞如 JoinableTaskFactory.Run 或 Task.Result 各位公共進入點，在那裡你必須同步的方法調用。它為內部成員可以使用不必要添加同步幀之間非同步幀，導致執行緒池用盡。</target>
        </trans-unit>
        <trans-unit id="VSSDK009_Title" translate="yes" xml:space="preserve">
          <source>Avoid synchronous blocks in non-public methods.</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">避免使用同步塊中的非公共方法。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>